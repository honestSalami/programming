
a tiny language called Z
https://chrisdone.com/posts/z/
lisp, markdown

Zmacs
https://en.wikipedia.org/wiki/Zmacs
a text editor variant of Emacs

tutorial of Oz
https://mozart.github.io/mozart-v1/doc-1.4.0/tutorial/

the mozart programming system
https://mozart.github.io/

clean
https://clean.cs.ru.nl/Clean

Software engineers handbook/language dictionary/qi
https://en.wikibooks.org/wiki/Software_Engineers_Handbook/Language_Dictionary/Qi
another language by mark tarver

shen homepage
http://www.shenlanguage.org/
mark tarver's language

mark tarver
http://www.marktarver.com/



a critique of abelson and sussman or why calculating is better than scheming
https://www.reddit.com/r/programming/comments/ujj3/a_critique_of_abelson_and_sussman_or_why/cutzn/

lisp ai
https://lisp-ai.blogspot.com/

road to lisp
https://road-to-lisp.blogspot.com/


steve losh
http://stevelosh.com/blog/

learn vimscript the hard way
http://learnvimscriptthehardway.stevelosh.com/


lisp is not an acceptable lisp
http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html


lisping at the jpl (jet propulsion laboratory)
http://www.flownet.com/gat/jpl-lisp.html


the eternal mainframe
http://www.winestockwebdesign.com/Essays/Eternal_Mainframe.html



Olin shivers
http://www.ccs.neu.edu/home/shivers/
I object to doing things that computers can do

scsh.net
https://scsh.net/docu/dessous.html
olin shivers

github page for scsh
https://github.com/scheme/scsh

the sre regular-expression notation
http://www.ccs.neu.edu/home/shivers/papers/sre.txt
olin shivers
the introduction describes the curse of lisp quite well

technical bibliography
http://www.ccs.neu.edu/home/shivers/citations.html#sre
articles by olin shivers

T (programming language)
https://en.wikipedia.org/wiki/T_(programming_language)

olin shivers: history of T
http://www.paulgraham.com/thist.html



lisp: good news, bad news, and how to win big
richard P. gabriel
https://www.dreamsongs.com/WIB.html

Dreamsongs' essays
https://www.dreamsongs.com/Essays.html



why founding a three-person startup with zero revenue is better than working for goldman sachs
https://blogs.itb.ac.id/djadja/2010/09/15/why-founding-a-three-person-startup-with-zero-revenue-is-better-than-working-for-goldman-sachs-adgrok/



On Smalltalk
http://onsmalltalk.com/

pharo
https://en.wikipedia.org/wiki/Pharo
a smalltalk environment



loper os
http://www.loper-os.org/
lisp, finite field arithmetic, ada, bitcoin
you can't get to the moon by piling up chairs



The Tunes os/language project
http://tunes.org/



two-bit history
computing through the ages
https://twobithistory.org/

how lisp became god's own programming language
https://twobithistory.org/2018/10/14/lisp.html

Eternal Flame
https://www.youtube.com/watch?v=u-7qFAuFGao
a song on how God used lisp to make the world


akkartik's mission
http://akkartik.name/about
to help people understand code faster, to make that nicer
"all software should reward curiosity"
"focus on helping the outsider comprehend a project"
"a new language or tool will have at best a short term effect
unless we're able to keep the big picture of our codebase comprehensible over
time as members join and leave it"
causes of creeping accidental complexity:
    backwards compatibility
    churn of personnel
    vestigial features
solutions:
    be friendly to outsiders
    be rewrite friendly
    lots of test, at every level of the stack
    white box testing. Testing everything affected by the function, not just
        its return value

Mu, a tiny new machine
https://github.com/akkartik/mu
an interesting experiment in literate programming

literate programming: knuth is doing it wrong
http://akkartik.name/post/literate-programming
organization of the code is more important than typesetting



tangible functional programming
conal Elliott
http://conal.net/papers/Eros/
graphically represent the values of functions

conal elliot webpage
http://conal.net/
automatic differentiation
parallel functional programming
haskell
tangible functional programming

learnable programming
http://worrydream.com/LearnableProgramming/
designing a programming system for understanding programs
bret victor
programming is a way of thinking, not a rote skill
people understand what they can see
how do we get people to understand programming?
we change programming. We turn it into something that's understandable by people

lost garden
http://www.lostgarden.com
art design and gaming
cool blog

lunar lost garden
http://lunar.lostgarden.com/
apparently, a hidden blog inside lost garden




wikilon introduction
https://awelonblue.wordpress.com/2014/09/29/introducing-wikilon/
a wiki inspired software platform and developmen environment
a wiki based IDE and live software platform
you can have a transactional view not only of the codebase, 
but also of the many web apps hosting it.
so, users can edit a codebase, see a live impact on their web applications,
and preserve this as a personal session view until they wish to share the 
changes by commiting them.

wikilon on github
https://github.com/dmbarbour/wikilon

Awelon programming language
https://github.com/dmbarbour/wikilon/blob/master/docs/AwelonLang.md
related to the wikilon



gitbook
https://www.gitbook.com/
documentation for you, your team, your users

programming with mydef
https://huizhou.gitbooks.io/programming-with-mydef/
a balance between being precize (doing exactly the thing we tell them)
and being able to guess what we want.
between doing things consistently and guessing what we want them to do.
mydef is the upper layer that can guess, and whatever language you are using
is the lower layer, the accurate one

write a python calculator imperatively
http://hz2.org/blog/python_calc.html
writing parsers in imperative programming, like a natural language
mydef and python



axiom (computer algebra system)
https://en.wikipedia.org/wiki/Axiom_(computer_algebra_system)
free, general purpose, and literate programming!


leo (text editor)
https://en.wikipedia.org/wiki/Leo_(text_editor)
open source text editor/outliner that features clones

leo's home page
http://leoeditor.com/
personal information manager (PIM) and IDE
python developed, with literate programming
leon, lion

Separation of mechanism and policy
https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy
a design principle in computer science.
the way to do it does not limit what you can do.
like the X windowing system does not tell you how windows should look,
only how you can draw pixels on the screen

Separation of concerns
https://en.wikipedia.org/wiki/Separation_of_concerns
each part of the program deals with one concern

the Scheme underground
https://github.com/scheme
a repository of some interesting scheme things, like:
a regular expression engine based on SRE notation
scsh
soosy, a Object Oriented system



cl-6502
a 6502 emulator in lisp
https://github.com/kingcons/cl-6502
emulating assembly language in common lisp
a readable CPU emulator

compiler basics (1): lisp to assembly
http://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html
a compiler in java, compiling lisp to assembly

compiler basecs: lisp to assembly
https://news.ycombinator.com/item?id=18530260
the hacker news site for the compiler basics (1): lisp to assembly

ulisp
a compiler for a lisp-like language targeting llvm ir, x86 assembly
https://github.com/eatonphil/ulisp
the github page for the project above

Lets build a compiler, by jack crenshaw
https://compilers.iecc.com/crenshaw/
a fifteen 15 part series, non technical introduction to compiler construction

game oriented assembly lisp
https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
the naughty dog lisp language.
used for the play station 2, jak and daxter, and the last of us.

lisp sucks in assembly
http://wiki.c2.com/?LispSucksInAssembly
a kitchen sink of confusing opinions about lisp...

how lisp implemented in assembly language
https://stackoverflow.com/questions/5865868/how-lisp-implemented-in-assembly-language#5871236
a list of resources on understanding lisp, and implementing it

bibliography of scheme related research
https://web.archive.org/web/20100824091403/http://library.readscheme.org/
the original lambda papers and more!!!
guy steele gerald sussman

indulge yourself
https://news.ycombinator.com/item?id=835020
the hacker news page where the bibliography of scheme was posted
some nice recommendations to reading them




the origin of CAR and CDR in lisp
http://www.iwriteiam.nl/HaCAR_CDR.html
its the 
    Contents of the Address Register and
    Contents of the Decrement Register.
also, the PDP10 and some assemnly talk

the origin of car and cdr in lisp (2005)
hacker news
https://news.ycombinator.com/item?id=16008239
the comments are interesting

successful lisp:
how to understand and use common lisp
david B. Lamkins
http://dept-info.labri.u-bordeaux.fr/~strandh/Teaching/MTP/Common/David-Lamkins/cover.html
kinda old, but probably good




the little javascripter
https://www.crockford.com/little.html
following "the little schemer", teaches you about recursion in javascript



structure and interpretation of computer programs
the wizard book
http://sarabander.github.io/sicp/
beautiful version
you make a scheme compiler by the end!

structure and interpretation of computer programs
https://xuanji.appspot.com/isicp/
interactive version!

easing into SICP
https://news.ycombinator.com/item?id=2115756
some recommendations for doing SICP at a nice pace, without stress

wizard book
https://mitpress.mit.edu/sites/default/files/sicp/index.html
the mit page for sicp

why sicp matters
https://people.eecs.berkeley.edu/~bh/sicp.html
brian harvey on an opinion

sicp distilled
an idiosyncratic tour of sicp in clojure
http://www.sicpdistilled.com/



# common lisp questions
why is elt not as common as car, cdr, first, rest?
https://stackoverflow.com/questions/19968900/why-is-elt-not-as-common-as-car-cdr-first-rest
answers:
    1
    too generic, you got car and cdr and c(a|d)+r for list.
    2
    elt is random access, list are not good for random access
    3
    you can nest cadadr. you cannot nest elt, which works only on the toplevel

integer division in common lisp?
https://stackoverflow.com/questions/2076862/integer-division-in-common-lisp
the 4 division functions:
    /
    floor
    ceiling
    truncate

understanding common lisp aref behavior
https://stackoverflow.com/questions/13959795/understanding-common-lisp-aref-behavior
so, setf knows magically the place form of its array argument at compile time
it is a macro
so, if you make a wrapper around aref, setf cannot inspect the array, because
that knowledge must be given explicitely, with a function companion.
you can make a function that gives that knowledge to setf...
but, really, setf expansion is a super hairy topic



let vs let* in common lisp
https://stackoverflow.com/questions/554949/let-versus-let-in-common-lisp
if let is just the parallel versin of let*'s serial processing,
why would we ever want let?
    the parallel thing is easier to understand
    it signals to the reader that nothing tricky is going on
    its more fundamental than let*
but the answers are divided, and none of the let and let* differentiation
arguments convince me
might be better to have just let*, instead of let.
